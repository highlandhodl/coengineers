---
title: My Claude Code Story
description: Why the fifth eureka moment changed everything
---

import { Aside } from '@astrojs/starlight/components';
import EmailSignup from '../../../components/EmailSignup.astro';

GPT-3.5 showed me AI could actually work. Midjourney gave me visuals. ElevenLabs opened up audio. MCP showed everyone was aligning.

Then Claude Code came along and just connected everything.

---

## The Problem I Had

Before Claude Code, my AI workflow was a mess. And I don't think I'm unusual in this.

I'd have ChatGPT in one tab, some files open locally, a Notion doc somewhere else, maybe an API I'm trying to call. Every task meant bouncing between apps, copying and pasting, losing track of what I'd already processed. It worked, kind of, but it was clunky.

MCP promised to fix this with tool interoperability. And it does help — I love MCP, I think the alignment across vendors is genuinely exciting. But in practice, context bloat is real. The more you connect, the slower and messier things get.

I needed something simpler.

---

## Why Claude Code Clicked

Right, so Claude Code has the worst marketing name of all time. It sounds like a coding tool for developers. It's not. It's a productivity tool that happens to be accessed through a terminal.

What makes it different is that you've got three things in one place:

1. **A really good LLM** — Opus 4.5 is probably the best I've worked with
2. **Access to your operating system** — it can read files, write files, run commands
3. **External connections** — API calls, MCP servers, whatever you need to integrate

That combination is what makes it powerful. You're not copying and pasting between apps anymore. You describe what you want, and it actually does it.

---

## The Moment It Clicked

I had customer discovery data sitting in Obsidian. Notes from calls, structured into a data model. I wanted to build an ElevenLabs voice agent that understood that customer context.

Normally that's a full day of work. Export the data, clean it up, format it for the API, write the integration code, debug it, test it, iterate. Boring, tedious, necessary.

Instead, I described what I wanted to Claude Code. Five minutes later I was talking to a working voice agent that understood my customer data.

Five minutes.

That's when I realised this wasn't just another AI tool. This was a different way of working.

<Aside type="note" title="The key insight">
Claude Code isn't about writing code. It's about describing what you want and having something that can actually make it happen. The terminal is just the interface — the value is in the capability.
</Aside>

---

## What I Actually Build With It

Here's the real stuff I use Claude Code for:

### Customer workflows

When I'm working with a new customer, I pull their brand kit using the Gemini API, build their discovery notes into an Obsidian data model, and run it through a pipeline to generate a deck. What used to take days takes hours. The AI handles the assembly; I handle the thinking.

### Content processing

Meeting transcripts, voice memos, PDFs, web pages — I've got slash commands that process all of these into structured formats. Same quality every time, no mental overhead.

### Image prompts

I build JSON structures for image generation and iterate on them systematically. It's basically software engineering for visuals. I tweak parameters, see what changes, refine until it's right.

### Voice agents

The ElevenLabs stuff I mentioned. Building conversational agents that actually understand context. AI gets you 80% of the way there; the testing and fine-tuning is where it becomes good.

### Building actual tools

This is the Week 4 content in the course. Spec-driven development where you describe what you want and Claude Code builds it. I've made internal tools, automations, even the CoEngineers website this way.

---

## Claude Code vs Claude.ai

I use both, but for different things.

**Claude Code** is for when I need to actually do something. Process files, build pipelines, create outputs, integrate with other tools. It's the execution layer.

**Claude.ai** is for when I need to think something through. Exploring ideas, working through problems, having a conversation. It's the thinking partner.

Most days I'm in Claude Code because most of my work involves making things, not just discussing them. But Claude.ai is still valuable when I'm at the earlier stages of figuring something out.

---

## The Learning Curve

I won't pretend there isn't one. If you've never used a terminal before, the first few days feel unfamiliar.

But here's the thing: you don't need to become a developer. You need to learn three things:

1. **Navigate folders** — know where your files are
2. **Run slash commands** — type `/command-name` and press enter
3. **Read error messages** — understand when something goes wrong

That's Week 1 of the course. After that, you're building real workflows.

The learning investment is measured in hours. The time savings are measured in weeks per year. That's a trade I'd make every time.

---

## Why I'm Teaching This

I built these workflows for myself. They save me hours every week. But I also spent years at QA and with Teach the Nation to Code learning how to make complex technology accessible to people who don't have a technical background.

CoEngineers is those two things combined. Real workflows that solve actual problems, taught in a way that doesn't assume you're a developer.

I'm not trying to turn people into programmers. I'm trying to help customer-focused people automate the tedious stuff so they can focus on what actually matters.

---

## What's Next?

Tomorrow: **What You'll Learn** — a week-by-week breakdown of the 31-day journey.

<EmailSignup
  heading="Want to follow along?"
  subheading="Get each post delivered to your inbox. No spam, ever."
/>